// Autogenerated code. Do not edit.

// This source code is dual-licensed under the Apache License, version
// 2.0, and the Mozilla Public License, version 1.1.
//
// The APL v2.0:
//
//---------------------------------------------------------------------------
//   Copyright (c) 2007-2016 Pivotal Software, Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//---------------------------------------------------------------------------
//
// The MPL v1.1:
//
//---------------------------------------------------------------------------
//   The contents of this file are subject to the Mozilla Public License
//   Version 1.1 (the "License"); you may not use this file except in
//   compliance with the License. You may obtain a copy of the License at
//   http://www.rabbitmq.com/mpl.html
//
//   Software distributed under the License is distributed on an "AS IS"
//   basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//   License for the specific language governing rights and limitations
//   under the License.
//
//   The Original Code is RabbitMQ.
//
//   The Initial Developer of the Original Code is Pivotal Software, Inc.
//   Copyright (c) 2007-2016 Pivotal Software, Inc.  All rights reserved.
//---------------------------------------------------------------------------

using RabbitMQ.Client.Exceptions;
namespace RabbitMQ.Client.Framing.Impl
{
    using RabbitMQ.Client.Events;
    using RabbitMQ.Client.Framing;
    using RabbitMQ.Client.Impl;

    public class Model : RabbitMQ.Client.Impl.ModelBase
    {
        public Model(RabbitMQ.Client.Impl.ISession session) : base(session) { }
        public Model(RabbitMQ.Client.Impl.ISession session, RabbitMQ.Client.ConsumerWorkService workService) : base(session, workService) { }
        public sealed override void ConnectionTuneOk(ConnectionTuneOk args)
        {
            ModelSend(args);
        }
        public sealed override void _Private_BasicCancel(
          string @consumerTag,
          bool @nowait)
        {
            ModelSend(new BasicCancel(consumerTag, nowait));
        }
        public sealed override void _Private_BasicConsume(BasicConsume args)
        {
            ModelSend(args);
        }
        public sealed override void _Private_BasicGet(
          string @queue,
          bool @autoAck)
        {
            ModelSend(new BasicGet(0, queue, autoAck));
        }
        public sealed override void _Private_BasicPublish(BasicPublishFull args)
        {
            ModelSend(args.PublishMethod, args.BasicProperties , args.Body);
        }
        public sealed override void _Private_BasicRecover(bool @requeue)
        {
            ModelSend(new BasicRecover(requeue));
        }
        public sealed override void _Private_ChannelClose(
          ushort @replyCode,
          string @replyText,
          ushort @classId,
          ushort @methodId)
        {
            ModelSend(new ChannelClose(replyCode, replyText, classId, methodId));
        }
        public sealed override void _Private_ChannelCloseOk()
        {
            ModelSend(new ChannelCloseOk());
        }
        public sealed override void _Private_ChannelFlowOk(bool @active)
        {
            ModelSend(new ChannelFlowOk(active));
        }
        public sealed override void _Private_ChannelOpen(
          string @outOfBand)
        {
            IMethod __repBase = ModelRpc(new ChannelOpen(outOfBand));
            if (!(__repBase is ChannelOpenOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ConfirmSelect(
          bool @nowait)
        {
            ConfirmSelect __req = new ConfirmSelect(nowait);
            if (nowait)
            {
                ModelSend(__req);
                return;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is ConfirmSelectOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ConnectionClose(
          ushort @replyCode,
          string @replyText,
          ushort @classId,
          ushort @methodId)
        {
            ConnectionClose __req = new ConnectionClose(replyCode, replyText, classId, methodId);
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is ConnectionCloseOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ConnectionCloseOk()
        {
            ModelSend(new ConnectionCloseOk());
        }
        public sealed override void _Private_ConnectionOpen(
          string @virtualHost,
          string @capabilities,
          bool @insist)
        {
            ModelSend(new ConnectionOpen(@virtualHost, @capabilities, @insist));
        }
        public sealed override void _Private_ConnectionSecureOk(
          string @response)
        {
            ModelSend(new ConnectionSecureOk(response));
        }
        public sealed override void _Private_ConnectionStartOk(ConnectionStartOk args)
        {
            ModelSend(args);
        }
        public sealed override void _Private_ExchangeBind(ExchangeBind args)
        {
            if (args.Nowait)
            {
                ModelSend(args);
                return;
            }
            IMethod __repBase = ModelRpc(args);
            if (!(__repBase is ExchangeBindOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ExchangeDeclare(
          string @exchange,
          string @type,
          ExchangeDeclareFlags flag,
          System.Collections.Generic.Dictionary<string, object> @arguments)
        {
            ExchangeDeclare __req = new ExchangeDeclare(0, exchange, type, flag, arguments);
            if ((flag & ExchangeDeclareFlags.NoWait) == ExchangeDeclareFlags.NoWait)
            {
                ModelSend(__req);
                return;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is ExchangeDeclareOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ExchangeDelete(
          string @exchange,
          ExchangeDeleteFlags flag)
        {
            ExchangeDelete __req = new ExchangeDelete(0, exchange, flag);
            if ((flag & ExchangeDeleteFlags.NoWait) == ExchangeDeleteFlags.NoWait)
            {
                ModelSend(__req);
                return;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is ExchangeDeleteOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_ExchangeUnbind(ExchangeUnbind args)
        {
            if (args.Nowait)
            {
                ModelSend(args);
                return;
            }
            IMethod __repBase = ModelRpc(args);
            if (!(__repBase is ExchangeUnbindOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_QueueBind(
          string @queue,
          string @exchange,
          string @routingKey,
          bool @nowait,
          System.Collections.Generic.Dictionary<string, object> @arguments)
        {
            QueueBind __req = new QueueBind(0, queue, exchange, routingKey, nowait, arguments);
            if (nowait)
            {
                ModelSend(__req);
                return;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is QueueBindOk __rep)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void _Private_QueueDeclare(
          string @queue,
          QueueDeclareFlags flag,
          System.Collections.Generic.Dictionary<string, object> @arguments)
        {
            ModelSend(new QueueDeclare(0, @queue, flag, @arguments));
        }
        public sealed override uint _Private_QueueDelete(
          string @queue,
          QueueDeleteFlags flag)
        {
            QueueDelete __req = new QueueDelete(0,@queue, flag);
            if ((flag & QueueDeleteFlags.NoWait) == QueueDeleteFlags.NoWait)
            {
                ModelSend(__req);
                return 0xFFFFFFFF;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is QueueDeleteOk __rep)) throw new UnexpectedMethodException(__repBase);
            return __rep.MessageCount;
        }
        public sealed override uint _Private_QueuePurge(
          string @queue,
          bool @nowait)
        {
            QueuePurge __req = new QueuePurge(0, @queue, @nowait);
            if (nowait)
            {
                ModelSend(__req);
                return 0xFFFFFFFF;
            }
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is QueuePurgeOk __rep)) throw new UnexpectedMethodException(__repBase);
            return __rep.MessageCount;
        }
        public override void BasicAck(
          ulong @deliveryTag,
          bool @multiple)
        {
            ModelSend(new BasicAck(deliveryTag, multiple));
        }
        public override void BasicNack(
          ulong @deliveryTag,
          BasicNackFlags settings)
        {
            ModelSend(new BasicNack(deliveryTag, settings));
        }
        public sealed override void BasicQos(
          uint @prefetchSize,
          ushort @prefetchCount,
          bool @global)
        {
            IMethod __repBase = ModelRpc(new BasicQos(@prefetchSize, @prefetchCount, @global));
            if (!(__repBase is BasicQosOk)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void BasicRecoverAsync(
          bool @requeue)
        {
            ModelSend(new BasicRecoverAsync(@requeue));
        }
        public override void BasicReject(
          ulong @deliveryTag,
          bool @requeue)
        {
            ModelSend(new BasicReject(deliveryTag, requeue));
        }
        public sealed override RabbitMQ.Client.Impl.BasicProperties CreateBasicProperties()
        {
            return new Framing.BasicProperties();
        }
        public sealed override void QueueUnbind(
          string @queue,
          string @exchange,
          string @routingKey,
          System.Collections.Generic.Dictionary<string, object> @arguments)
        {
            QueueUnbind __req = new QueueUnbind(0,@queue,@exchange,@routingKey,@arguments);
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is QueueUnbindOk)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void TxCommit()
        {
            TxCommit __req = new TxCommit();
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is TxCommitOk)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void TxRollback()
        {
            TxRollback __req = new TxRollback();
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is TxRollbackOk)) throw new UnexpectedMethodException(__repBase);
        }
        public sealed override void TxSelect()
        {
            TxSelect __req = new TxSelect();
            IMethod __repBase = ModelRpc(__req);
            if (!(__repBase is TxSelectOk))
            {
                throw new UnexpectedMethodException(__repBase);
            }
        }
        public sealed override bool DispatchAsynchronous(RabbitMQ.Client.Impl.AssembledCommandBase<FrameBuilder> cmd)
        {
            IMethod __method = cmd.Method;
            switch ((__method.ProtocolClassId << 16) | __method.ProtocolMethodId)
            {
                case 3932240:
                    {
                        BasicAck __impl = (BasicAck)__method;
                        HandleBasicAck(new BasicAckEventArgs(__impl.m_deliveryTag,__impl.m_multiple));
                        return true;
                    }
                case 3932190:
                    {
                        BasicCancel __impl = (BasicCancel)__method;
                        HandleBasicCancel(__impl.ConsumerTag,__impl.Nowait);
                        return true;
                    }
                case 3932191:
                    {
                        BasicCancelOk __impl = (BasicCancelOk)__method;
                        HandleBasicCancelOk(__impl.ConsumerTag);
                        return true;
                    }
                case 3932181:
                    {
                        BasicConsumeOk __impl = (BasicConsumeOk)__method;
                        HandleBasicConsumeOk(__impl.ConsumerTag);
                        return true;
                    }
                case 3932220:
                    {
                        BasicDeliver __impl = (BasicDeliver)__method;
                        HandleBasicDeliver(new BasicDeliverEventArgs(
                            __impl.ConsumerTag,__impl.DeliveryTag,__impl.Redelivered,
                            __impl.Exchange,__impl.RoutingKey,cmd.Header,
                            cmd.Body.ToByteArray()));
                        return true;
                    }
                case 3932232:
                    {
                        HandleBasicGetEmpty();
                        return true;
                    }
                case 3932231:
                    {
                        BasicGetOk __impl = (BasicGetOk)__method;
                        HandleBasicGetOk(new BasicGetResult (
                            __impl.DeliveryTag,__impl.Redelivered,__impl.Exchange,__impl.RoutingKey,
                            __impl.MessageCount,cmd.Header,cmd.Body.ToByteArray()));
                        return true;
                    }
                case 3932280:
                    {
                        BasicNack __impl = (BasicNack)__method;
                        HandleBasicNack(new BasicNackEventArgs
                        {
                            DeliveryTag = __impl.DeliveryTag,
                            Settings = __impl.Settings
                        }
                          );
                        return true;
                    }
                case 3932271:
                    {
                        HandleBasicRecoverOk();
                        return true;
                    }
                case 3932210:
                    {
                        BasicReturn __impl = (BasicReturn)__method;
                        HandleBasicReturn(
                          __impl.ReplyCode,
                          __impl.ReplyText,
                          __impl.Exchange,
                          __impl.RoutingKey,
                          cmd.Header,
                          cmd.Body.ToByteArray());
                        return true;
                    }
                case 1310760:
                    {
                        ChannelClose __impl = (ChannelClose)__method;
                        HandleChannelClose(
                          __impl.ReplyCode,
                          __impl.ReplyText,
                          __impl.ProtocolClassId,
                          __impl.ProtocolMethodId);
                        return true;
                    }
                case 1310761:
                    {
                        HandleChannelCloseOk();
                        return true;
                    }
                case 1310740:
                    {
                        ChannelFlow __impl = (ChannelFlow)__method;
                        HandleChannelFlow(
                          __impl.Active);
                        return true;
                    }
                case 655420:
                    {
                        ConnectionBlocked __impl = (ConnectionBlocked)__method;
                        HandleConnectionBlocked(
                          __impl.Reason);
                        return true;
                    }
                case 655410:
                    {
                        ConnectionClose __impl = (ConnectionClose)__method;
                        HandleConnectionClose(
                          __impl.ReplyCode,
                          __impl.ReplyText,
                          __impl.ProtocolClassId,
                          __impl.ProtocolMethodId);
                        return true;
                    }
                case 655401:
                    {
                        ConnectionOpenOk __impl = (ConnectionOpenOk)__method;
                        HandleConnectionOpenOk(
                          __impl.Reserved1);
                        return true;
                    }
                case 655380:
                    {
                        ConnectionSecure __impl = (ConnectionSecure)__method;
                        HandleConnectionSecure(
                          __impl.Challenge);
                        return true;
                    }
                case 655370:
                    {
                        ConnectionStart __impl = (ConnectionStart)__method;
                        HandleConnectionStart(
                          __impl);
                        return true;
                    }
                case 655390:
                    {
                        ConnectionTune __impl = (ConnectionTune)__method;
                        HandleConnectionTune(new ConnectionTuneDetails(__impl.ChannelMax, __impl.FrameMax, __impl.Heartbeat));
                        return true;
                    }
                case 655421:
                    {
                        HandleConnectionUnblocked();
                        return true;
                    }
                case 3276811:
                    {
                        QueueDeclareOk __impl = (QueueDeclareOk)__method;
                        HandleQueueDeclareOk(
                          __impl.Queue,
                          __impl.MessageCount,
                          __impl.ConsumerCount);
                        return true;
                    }
                default: return false;
            }
        }
    }
}